% vim: filetype=tex spell

\chapter{Conclusion and Future work}

\section{Conclusion}

\section{Future Work}

\subsection{System Operations Overview}

\Cref{fig:sysopflow} shows the system operations flow. The code starts running after the separation switch is switched and the power system applies power to all systems. Before starting any operations the \ac{ACDS} waits for the on command from the \ac{CDH} board. After the \ac{ACDS} board receives the on command the \ac{ACDS} sends a command to the \ac{LEDL} board to tell it to start taking sensor data. Once sensor data is received the \ac{ACDS} starts to run the detumble algorithm. The Kalman filter needs to know the location of the satellite for it to operate properly so orbital elements must be uploaded before the Kalman filter can start running. Once the Kalman filter knows the location of the satellite it still needs some time to converge to a solution. During this time the \ac{ACDS} remains in detumble mode even if the rates have slowed enoughs to exit. Once the Kalman filter is locked and the rates have sufficiently slowed the \ac{ACDS} switches into mode 2. Mode two is run for a set number \todo{figure out how many and put the number here} of orbits (measured by timing). After mode 2 is complete Mode 3 starts. The \ac{ACDS} remains in mode 3 indefinably unless one of undesirable conditions is detected, see \cite{Mentch11} for details, which causes the \ac{ACDS} to attempt to kick the satellite out of the undesirable alignment and then re-stabilize by transitioning back to mode 2.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance = 0.5cm, auto]
    % Place nodes
    \node [block] (sep) {Separation};
    \node [block,below=of sep] (cmd) {On Command from \acs{CDH}};
    \node [block,below=of cmd] (sens) {Send Start Data Collection Command to \acs{LEDL}};
    \node [block,node distance= 2cm,right=of sep] (detumble) {Detumble};
    \node [decision,below=of detumble] (dchk) {Rates and Kalman filter are ready};
    \node [block,below=of dchk] (m2) {Mode 2};
    \node [decision,below=of m2] (m2chk) {Has Mode 2 time elapsed?};
    \node [block,below=of m2chk] (m3) {Mode 3};
    \node [decision,below=of m3] (cchk) {Correct Alignment?};
    \node [block,node distance=2cm,right=of cchk]  (cor) {apply correction};
    \node [block,above=of cor]  (timer) {reset Mode 2 timer};

    \path[conn] (sep) -- (cmd);
    \path[conn] (cmd) -- (sens);
    \path[conn] (sens.east) -- ++(0.5cm,0) |- (detumble);

    \path[conn] (detumble) -- (dchk);
    \path[conn] (dchk) --  node [near start] {yes} (m2);
    \path[conn] (dchk.east) -- node [near start] {no} ++(0.7cm,0) |-  (detumble);
    \path[conn] (m2) -- (m2chk);
    \path[conn] (m2chk) -- node [near start] {yes} (m3);
    \path[line] (m2chk.east) -- node [near start] {no} ++(0.7cm,0) |- (m2);

    \path[conn] (m3) -- (cchk);
    \path[conn] (cchk) -- node [near start] {no} (cor);
    \path[conn] (cor) -- (timer);
    \path[conn] (timer) |- (m2);

    \path[conn] (cchk.west) -- node [near start] {yes} ++(-0.7cm,0) |- (m3);

    \end{tikzpicture}
    \caption{System operations chart}
    \label{fig:sysopflow}
\end{figure}

The flow case the flow from \cref{fig:sysopflow} can be disrupted. This can happen due to commands from the ground station or if the gyros detect that the sattelite is rotating too fast. The ground station can force the \ac{ACDS} into any mode and ether let it go with the normal flow or stay in a particular mode. This allows for recovery in case the system does not function as expected.

If the gyros detect that the satellite is rotating too fast then they will automatically send the \ac{ACDS} into a safe mode where the \ac{ACDS} does not run. It is possible that the \ac{ACDS} could get into a situation where the algorithm speeds up the rotation instead of slowing it down. In this situation the best thing to do is for the \ac{ACDS} to stop and wait for further intervention from the ground.

\subsubsection{Additional Ground station Commands}

In order for the Kalman filter to work it needs the orbital elements for the satellite. These must be uplinked from the ground because they change as the orbit decays. In addition gains for the control algorithm and Kalman filter may need to be changed in flight to account for unexpected conditions. 


\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance = 0.5cm, auto]
    % Place nodes
    \node [block] (field) {Magnetic Field Measurements};
    \node [block,right=of field] (cal) {Torquer offset correction};
    \node [block,node distance=0.7cm,right=of cal] (alg) {Torque algorithm};
    \node [block, right=of alg] (q) {Torque Quantization};
    \node [block, above=of alg] (rates) {Kalman Filter};
    \node [block,above=of cal] (igrf) {Magnetic field model};
    \node [block,left=of igrf] (pos) {Orbit timing};
    \node [block, above=of q] (win) {Bias Window Determination};
    \node [block, right=of q] (choose) {Choose Torquers to fire};
    \node [block,node distance=0.7cm, right=of choose] (fire) {Fire Torquers};
    \node [block, below=of choose] (mem) {Torquer Status Tracking};
    \node [block,node distance=0.86cm, below=of fire] (sens) {Torquer feedback};

    %draw lines
    \path [conn] (field) -- (cal);
    \path [conn] (cal.east) -- ++(0.3cm,0) |- (rates.190);
    \path [conn] (cal) -- (alg);
    \path [conn] (rates) -- (alg);
    \path [conn] (win) -- (alg);
    \path [conn] (alg) -- (q);
    \path [conn] (q) -- (choose);
    \path [conn] (choose) -- (fire);

    \path [conn] (choose.east) -- ++(0.3cm,0) |- (mem.10);
    \path [phconn] (fire) -- (sens);

    \path [conn] (sens.west) -- ++(-0.3cm,0) |- (mem);
    \path [conn] (mem) -- (choose);
    \path [conn] (mem) -| (cal);

    \path [conn] (pos) -- (igrf);
    \path [conn] (igrf.east) -- ++(0.3cm,0) |- (rates.west);

    \path [conn] (pos) |- ([yshift=0.3cm]win.north) -- (win);

    \end{tikzpicture}
    \caption{Overall Software Block Diagram}
    \label{fig:swblock-future}
\end{figure}

\subsubsection{Mode 2}

\Cref{fig:mode2} shows the Mode 2 torque algorithm block diagram. Torque is calculated the same way as in Mode 1 but this time a bias is added depending on which region of the orbit the satellite is in. The bias tends to cause the satellite to rotate. This causes the algorithm to cancel out the bias. This is prevented by preventing the resulting dipole moment from being in the opposite direction as the bias. Outside of the bias regions the torquers are set to produce no torque.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance = 0.5cm, auto]
    % Place nodes
    \node [input] (field) {Magnetic Field};
    \node [block, right=of field] (alg) { $k \frac{\vect{\omega}_{err} \cross \vect{B}}{\vect{B} \cdot \vect{B}}$ };
    \node [input, right=of alg] (rates) {Rotation Rates};
    \node [oppr,node distance=1cm,below=of alg] (sum) {+};
    \node [block,node distance=1.2cm,left=of sum] (bias) {Mode 2 bias table};
    \node [input,left=of bias] (win) {Bias Window};
    \node [block,node distance=1cm,below=of sum] (fix) {Bias Fix};
    \node [block,below=of fix] (coast) {Coast?};
    \node [point, below=of coast] (out) {};

    %draw lines
    \path [conn] (field) -- (alg);
    \path [conn] (rates) -- (alg);
    \path [conn] (alg) -- (sum);
    \path [conn] (win) -- (bias);
    \path [conn] (bias) -- (sum);
    \path [conn] (sum) -- (fix);
    \path [conn] (fix) -- (coast);
    \path [conn] (win) |- (coast);
    \path [conn] (coast) -- (out);
    \path [conn] (bias) |- (fix);

    \end{tikzpicture}
    \caption{Mode 2 Torque Algorithm Block Diagram}
    \label{fig:mode2}
\end{figure}

\subsubsection{Mode 3}

\Cref{fig:mode3} shows the Mode 3 torque algorithm block diagram. This is similar to Mode 2 except only the north pole bias window is used and outside the bias window torque is generated to slow rotation rates.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance = 0.5cm, auto]
    % Place nodes
    \node [input] (field) {Magnetic Field};
    \node [block, right=of field] (alg) { $k {\frac{\vect{\omega}_{err} \cross \vect{B}}{\vect{B} \cdot \vect{B}}}$ };
    \node [input, right=of alg] (rates) {Rotation Rates};
    \node [oppr,node distance=1cm,below=of alg] (sum) {+};
    \node [block,node distance=1.2cm,left=of sum] (bias) {Mode 3 bias table};
    \node [input,left=of bias] (win) {Bias Window};
    \node [block,node distance=1cm,below=of sum] (fix) {Bias Fix};
    \node [point, below=of fix] (out) {};

    %draw lines
    \path [conn] (field) -- (alg);
    \path [conn] (rates) -- (alg);
    \path [conn] (alg) -- (sum);
    \path [conn] (win) -- (bias);
    \path [conn] (bias) -- (sum);
    \path [conn] (sum) -- (fix);
    \path [conn] (fix) -- (out);
    \path [conn] (bias) |- (fix);


    \end{tikzpicture}
    \caption{Mode 3 Torque Algorithm Block Diagram}
    \label{fig:mode3}
\end{figure}

\subsubsection{Mode Switching}

Mode switching on \ac{ARC} will be time based. The original simulation used the rotation rates to switch from Mode 1 mode to Mode 2 but it was found that when the satellite did not have full knowledge of rotation rates, as will be the case if they are determined from magnetic field, then the mode was switched too soon. The switch from Mode 2 to Mode 3 is timed to be about 10 orbits after the switch into Mode 2. Once in Mode 3 no more automated mode switching is done. Modes can also be switched at all times via ground station command.

\begin{comment}
\subsubsection{Bias Window Determination}

\Cref{fig:biaswin} shows how the bias window determination will work. To determine where \ac{ARC} is within the orbit, peaks are found in the magnitude of the magnetic field. The field magnitude is used because it is independent of attitude. The magnitude of the field is greatest at the south pole but the magnetic north pole is located closer to the geographic north pole so it's peaks are more consistent. South pole peaks are filtered out first by eliminating peaks that are ether too high or too low to be a north pole peak. Peaks are further filtered by tracking the timing of past peaks and rejecting peaks that happen too soon. If a second peak is detected very soon after a north pole peak then it is assumed to be a double peak and the average peak time is taken. After the north poles are found the orbital period can be determined and orbital progress can be tracked. The current bias window is determined using the current orbital progress and a lookup table. In case the automatic orbit tracking does not work properly it is possible to upload timing parameters for the orbit tracking to use instead.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance = 0.5cm, auto]
    % Place nodes
    \node [input] (field) {Field Measurements};
    \node [block,below=of field] (mag) {Vector Magnitude};
    \node [block,right=of mag] (peak) {Peak Detect};
    \node [block,right=of peak] (level) {Level Check};
    \node [block,right=of level] (pole) {North Pole Detect};
    \node [block,right=of pole] (gen) {Orbit tracking};
    \node [block,below=of gen] (time) {Timing Source};
    \node [block,above=of gen] (upload) {Timing Parameter Upload};
    \node [block,right=of gen] (lookup) {Bias Window Lookup};
    \node [point,right=of lookup] (out) {};

    %draw lines
    \path [conn] (field) -- (mag);
    \path [conn] (mag) -- (peak);
    \path [conn] (peak) -- (level);
    \path [conn] (level) -- (pole);
    \path [conn] (pole) -- (gen);
    \path [conn] (gen) -- (lookup);
    \path [conn] (lookup) -- (out);
    \path [conn] (time) -- (gen);
    \path [conn,dashed] (upload) -- (gen);

    \end{tikzpicture}
    \caption{Bias Window Determination Block Diagram}
    \label{fig:biaswin}
\end{figure}

\end{comment}

\begin{comment}
\subsubsection{Rotation Rate Calculations}

The rotation rate is calculated using the magnetic field measurements. \Cref{eq:magrate} shows how to calculate the rotation rate using magnetic field measurements. In \cref{eq:magrate} $\dot{\vec{B}}$ is calculated using there magnetic field measurements and the central difference formula as suggested in \cite{Mentch11}.

\begin{equation}
    %TODO: add dot over B
    \vec{\omega}={\frac{\dot{\vec{B}} \cross \vec{B}}{\vec{B} \cdot \vec{B}}}
    \label{eq:magrate}
\end{equation}
\end{comment}

\subsubsection{Kalman Filter}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance = 0.5cm, auto]
    % Place nodes
        \node [block] (pstate) {Project State};
        \node [block,below=of pstate] (pcov) {Project Error Covariance Ahead};
        \node [block,right=of pcov] (gain) {Compute Kalman Gain};
        \node [block,right=of gain] (ustate) {Update state Estimate};
        \node [input,right=of ustate,text width = 3cm] (meas) {Measurement Input};
        \node [block,right=of pstate] (ucov) {Update Error Covariance};


    %draw lines

    \path [conn] (pstate) -- (pcov);
    \path [conn] (pcov) -- (gain);
    \path [conn] (gain) -- (ustate);
    \path [conn] (meas) -- (ustate);
    \path [conn] (ustate) |- (ucov);
    \path [conn] (ucov) -- (pstate);


    \end{tikzpicture}
    \caption{Extended Kalman Filter}
    \label{fig:eKalman}
\end{figure}

\begin{comment}

\begin{equation}
    F_k = 
        \begin{bmatrix}
              0                &   \hat {\omega} _3 & - \hat {\omega} _2  & \frac{1}{2} & 0           & 0           \\
            - \hat {\omega} _3 &   0                &   \hat {\omega} _1  & 0           & \frac{1}{2} & 0           \\
              \hat {\omega} _2 & - \hat {\omega} _1 &   0                 & 0           & 0           & \frac{1}{2} \\
            0 & 0 & 0 & 0                  & K_1 \hat{\omega}_3 & K_1 \hat{\omega}_2 \\
            0 & 0 & 0 & K_2 \hat{\omega}_3 & 0                  & K_2 \hat{\omega}_1 \\
            0 & 0 & 0 & K_3 \hat{\omega}_2 & K_3 \hat{\omega}_1 & 0                  \\
        \end{bmatrix}
\end{equation}

\begin{equation}
    \Phi \left( t \right) = \matt{I} + \matt{F} t = 
        \begin{bmatrix}
              1                  &   \hat {\omega} _3 t & - \hat {\omega} _2 t  & \frac{1}{2} t & 0             & 0             \\
            - \hat {\omega} _3 t &   1                  &   \hat {\omega} _1 t  & 0             & \frac{1}{2} t & 0             \\
              \hat {\omega} _2 t & - \hat {\omega} _1 t &   1                   & 0             & 0             & \frac{1}{2} t \\
            0 & 0 & 0 & 1                    & K_1 \hat{\omega}_3 t & K_1 \hat{\omega}_2 t \\
            0 & 0 & 0 & K_2 \hat{\omega}_3 t & 1                    & K_2 \hat{\omega}_1 t \\
            0 & 0 & 0 & K_3 \hat{\omega}_2 t & K_3 \hat{\omega}_1 t & 1                    \\
        \end{bmatrix}
\end{equation}

\begin{equation}
    \matt{Q} = Q \matt{I}
\end{equation}

\begin{equation}
    \matt{Q}_k = \int _0 ^ {T_s} \matt{\Phi} \left( \tau \right) \matt{Q} \matt{\Phi} \transpose \left( \tau \right) d\tau = Q \int _0 ^ {T_s} \matt{\Phi} \left( \tau \right) \matt{\Phi} \transpose \left( \tau \right) d\tau
\end{equation}


\begin{equation}
    \matt{Q}_k = Q \int _0 ^ {T_s} \matt{\Phi} \left( \tau \right) \matt{\Phi} \transpose \left( \tau \right) d\tau
\end{equation}
\end{comment}

