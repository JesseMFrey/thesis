% vim: filetype=tex spell

\chapter{Software}
\label{ch:Software}

The main responsibility of the \ac{ACDS} software is to determine which torquer to flip each time step. The \ac{ACDS} also needs to keep track of ``house keeping'' information, sensor readings, torquer states and internal control system states so that the performance of the algorithm can be tracked on the ground. 

\section{Overview}

In order to determine which torquer to flip the \ac{ACDS} needs sensor inputs. The sensors are read by the \ac{LEDL} board and forwarded to the \ac{ACDS} using the \ac{ARC}bus. The \ac{ACDS} needs to communicate with the \ac{COMM} board to respond to ground station commands and downlink housekeeping data.

\begin{figure}[H]
    \centering
    %separator for parallel lines
    \def\linesep{6}
    \begin{tikzpicture}[node distance = 3cm, auto]
        % Place nodes
        \node [block,minimum height=8cm]            (AB) {\acs{ARC}bus interface};

        \node [block,left of=AB,node distance=6cm]  (LEDL) {\acs{LEDL}};
        \node [block,left of=AB,yshift=-3cm]        (CDH) {\acs{CDH}};
        \node [block,left of=CDH]                   (COM) {\acs{COMM}};

        \node [bigblock,right of=AB,node distance=7cm,minimum height=5cm,yshift=1.5cm] (core) {\acs{ACDS} software};
        \node [bigblock,below of=core,node distance=4.5cm,minimum height=2cm] (HC) {House Keeping};


        \path [flow] (AB.58) -- node  {Sensor Data} (core.170);
        \path [flow] (core.190) -- node {Sensor Commands} (AB.48);

        \path [flow] (AB.00) -- node {Ground Station} node [below]{Commands} (core.226);

        \path [flow] (core) -- (HC);
        \path [flow] ([yshift= \linesep]AB.290)  -- node [above]{Data Log Query} ([yshift= \linesep]HC.west);
        \path [flow] ([yshift=-\linesep]HC.west) -- node [below]{Recalled Data} ([yshift=-\linesep]AB.290);

        \path [flow] ([yshift= \linesep]COM.east) -- ([yshift= \linesep]CDH.west);
        \path [flow] ([yshift=-\linesep]CDH.west) -- ([yshift=-\linesep]COM.east);

        \path [flow] ([yshift= \linesep]CDH.east) -- ([yshift= \linesep]AB.250);
        \path [flow] ([yshift=-\linesep]AB.250)   -- ([yshift=-\linesep]CDH.east);

        \path [flow] ([yshift=-\linesep]LEDL.east) -- node [below]{Sensor Data}     ([yshift=-\linesep]AB.west);
        \path [flow] ([yshift= \linesep]AB.west)   -- node [above]{Sensor Commands} ([yshift= \linesep]LEDL.east);


    \end{tikzpicture}
    \caption{\acs{ACDS} software overview}
\end{figure}

\section{System Operations Overview}

The \ac{ACDS} starts running after the separation switch is switched and the power system applies power to all systems. Before starting any operations the \ac{ACDS} waits for the on command from the \ac{CDH} board. After the \ac{ACDS} board receives the on command the \ac{ACDS} sends a command to the \ac{LEDL} board to tell it to start taking sensor data. Once sensor data is received the \ac{ACDS} starts to run the detumble algorithm.


\subsection{Ground Station Commands}

The ground station can force the \ac{ACDS} into any mode and ether let it go with the normal flow or stay in a particular mode. This allows for recovery in case the system does not function as expected.

\subsection{Rotation Runaway}

If the gyros detect that the satellite is rotating too fast then they will automatically send the \ac{ACDS} into a safe mode where the \ac{ACDS} does not run. It is possible that the \ac{ACDS} could get into a situation where the algorithm speeds up the rotation instead of slowing it down. In this situation the best thing to do is for the \ac{ACDS} to stop and wait for further intervention from the ground.

\section{Incoming Commands\textbackslash Info}

The \ac{ACDS} must respond to incoming commands that change its operation mode or uplink data. Because the \ac{ACDS} is an experimental system, it may run into unexpected problems. By uplinking commands some of the possible problems can be fixed in flight. 

\begin{comment}
\begin{itemize}
    \item Ground Station Commands
        \begin{itemize}
            \item Uplink Orbit Data
            \item Stop \ac{ACDS}
            \item Force Mode
        \end{itemize}
    \item Sensor Data
\end{itemize}
\end{comment}

\section{Algorithm Software}

\Cref{fig:swblock} shows the overall software block diagram for the \ac{ACDS} system. Field measurements from the magnetometer are calibrated using the current torquer state and a table of field measurements at different torquer states. The calibrated readings are used to calculate rotation rate and latitude which a long with the field readings are used to calculate the torque that should be applied to the satellite. The torque is then quantized based on \cref{fig:lpmtq}. The torquers to flip are chosen based current knowledge of torquer stated as well as the desired torque.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance = 2.6cm, auto]
    % Place nodes
    \node [block] (field) {Magnetic Field Measurements};
    \node [block,right of=field] (cal) {Torquer offset correction};
    \node [block, right of=cal] (alg) { $C {\dot{\vect{B}}}$ };
    \node [block, right of=alg] (q) {Torque Quantization};
    \node [block, right of=q] (choose) {Choose Torquers to fire};
    \node [point, right of=choose] (fb) {};
    \node [block, right of=fb,node distance=1.5cm] (fire) {Fire Torquers};
    \node [block, below of=choose] (mem) {Torquer Status Tracking};
    \node [block, below of=fire] (sens) {Torquer feedback};

    %draw lines
    \path [conn] (field) -- (cal);
    \path [conn] (cal) -- (alg);
    \path [conn] (alg) -- (q);
    \path [conn] (q) -- (choose);
    \path [conn] (choose) -- (fire);

    \path [conn] (fb) |- (mem.10);
    \path [phconn] (fire) -- (sens);

    \path [conn] (sens.190) -- (mem.350);
    \path [conn] (mem) -- (choose);
    \path [conn] (mem) -| (cal);

    \end{tikzpicture}
    \caption{Overall Software Block Diagram}
    \label{fig:swblock}
\end{figure}

\subsection{B-dot Algorithm}

\label{sec:bdot-desc}

The B-dot algorithm is used to detumble the \ac{ARC}. The B-dot algorithm uses the time derivative of the magnetic field, $\dot{\vec{B}}$, to calculate the magnetic dipole moment that the torquers should generate. This is a method that is widely used on other CubeSats \todo{Find some B-dot reference(s)} that have magnetic \ac{ACDS}. In this mode the magnetic dipole moment is simply set to a value that is proportional to the derivative of the magnetic field. The gain for the B-dot controller needs to be negative in order to stop the motion of the magnetic field. This could be done by adding a negative sign to the torque expression but, in code, it is simpler to have a negative gain.

\section{Auxiliary Software Functions}

In addition to the algorithm software the \ac{ACDS} also requires some auxiliary software to function. In order to generate the proper dipole moment the status of the torquers must be tracked in software so that the right torquer can be flipped. The torquer status also needs to be tracked so that the torquer offsets can be subtracted from the magnetometer measurements. 

\subsection{Torquer Flipping Logic}

The torquer flipping logic keeps track of the torquer status and sets the torquers to the dipole moment that is closest to the dipole moment requested by the control algorithm. The torquer flipping logic also attempts to distribute the flips somewhat evenly across the torquers in any given axis. This way if there are any degradation effects, in the torquer field or the hardware, they will be minimized. 

\subsubsection{Status Tracking}

The status of each torquer is tracked by the flipping logic. This includes flags to indicate if each torquer has been flipped and has had errors being flipped. The last four torquers that were flipped are also tracked. This is used to chose which torquer to flip.

When it is time to flip a torquer the software looks at the current torquer status to figure out which direction a torquer needs to be flipped in. Next the software looks for the torquer that can be flipped in that direction that was flipped the least recently and flips it. This way the torquer flips are distributed across the torquers in a given axis. If torquers are marked as uninitialized then they are flipped first before other torquers so that all torquers are in a known state as quickly as possible.

\subsubsection{torquer feedback}

Before and after each torquer flip the torquer feedback comparators are read. After the torquer flip is complete the feedback values are examined to determine if the torquer flipped. If the capacitor voltage was below the upper threshold before the flip then an error is flagged in the torquer status indicating that there is a problem with the capacitor. If the capacitor voltage after a flip is not below the lower threshold then there is likely a bad connection to the torquer windings. Torquers that failed to flip are flagged and not flipped in the future. It is possible that the comparator could malfunction and indicate that it is both above the upper threshold and below the lower threshold in this case a flag is set to indicate the error and the torquer is assumed to have flipped as normal.

\subsection{Torquer Compensation}

Because the geometry of the system should not change in flight, the field offset seen by each magnetometer depends on the combination of torquer states. By taking measurements in the Helmholtz cage these offsets can be calculated and eliminated during flight in order to measure Earth's magnetic field.

\subsubsection{Compensation Data Set}

\label{sec:comp-dat-set}

There are a total of 12 \acp{LPMT} on the \ac{ACDS}. Each \ac{LPMT} has two states which results in a total of 4096 possible states. If the offset for each state uses four bytes this results in a data set that is 16kB. The field produced at each state however, is the sum of the field contributions of all of the torquers. The dataset can be reduced by doing three separate calibration, one for the set of torquers in each axis. The calibrations are then combined to get a calibration set where one offset is chosen for each axis and added together to get the full offset this reduces the number of states to $3*16 + 1 = 49$ which is only about 200 bytes of data, much reduced from using all possible states.

\subsubsection{Compensation Routine}

\label{sec:tq-comp}

To calculate the compensation values for the torquers the calibration procedure described in \cref{sec:magcal} is run for each combination of torquer states. The results of the compensation is $C_1$, $C_2$, $C_4$ and $ C_5$ which are the same calibration constants computed with the magnetometer calibration routine. In addition there is one common pair of offsets and then 3 sets of 16 offsets for each set of torquers. The total offset value for a given torquer state is the sum of the common offset value and an offset determined by the state of the torquers in the X, Y and Z axes.

\subsection{Data Logging}

During \ac{ACDS} operations data is collected during flight. This data is stored in nonvolatile memory and can be recalled and transmitted to the ground in order to evaluate the \ac{ACDS} system performance. The data that is recorded is shown in \cref{tab:logdat}

\begin{comment}
\begin{itemize}
    \item magnetometer and gyro readings
    \item torquer status
    \item mode
    \item algorithm intermediate results
    \item torquers flipped
    \item torquer feedback
    \item Kalman filter status
    \item Kalman filter internal variables
    \item Kalman filter state
    \item \todo[inline]{More?}
\end{itemize}
\end{comment}

\begin{table}[H]
    \centering
    \caption{\ac{ACDS} operations data format}
    \label{tab:logdat}
    \begin{tabular}{|l|c|c|}
        \hline
        Data&size (bits)&Format\\
        \hline
        mode&2&unsigned integer\\
        \hline
        Time Stamp&32&unsigned integer\\
        \hline
        torquer status&48&flags\\
        \hline
        magnetometer readings&48&unsigned integer (one per axis)\\
        \hline
        gyro readings&36&unsigned integers (one per axis)\\
        \hline
        algorithm intermediate results&TBD&\\
        \hline
        torquers flipped&48&unsigned integer (one per axis)\\
        \hline
        torquer feedback&12&flags\\
        \hline
        Kalman filter status&TBD&\\
        \hline
        Kalman filter internal variables&TBD&\\
        \hline
        \multicolumn{1}{|r|}{\bfseries Total :}&TBD&\\
        \hline
    \end{tabular}
    \todo[inline]{Resolve DBD's}
\end{table}

\subsection{On Board data processing}

Because the downlink data speed is limited, it is necessary to reduce the data that needs to be downlinked. One way to do this is to do some level of on board processing to reduce the data before it is downlinked. For the \ac{ACDS} system this will most likely take the form of returning only the desired data from the recorded data set or returning min/max values from within a data set. 

\subsection{Beacon Data}

The beacon data is transmitted at a fixed rate and provides information about the present state of the satellite. The beacon data could be the only data that is available to diagnose the system. The beacon data must contain enough data to be useful but not so much data that the beacon packets are too big. The beacon data should include raw sensor information as well as information on torquer status. The beacon data from the \ac{ACDS} is shown in \cref{tab:beacondat}

\begin{table}[H]
    \centering
    \caption{Beacon Data format}
    \label{tab:beacondat}
    \begin{tabular}{|l|c|c|}
        \hline
        Data&size (bytes)&Format\\
        \hline
        current magnetometer readings&6&signed integers (one per axis)\\
        \hline
        Mode&1&unsigned integer\\
        \hline
        current torquer status&3&flags\\
        \hline
        number of torquer flips so far & 6 & unsigned integers (one per axis)\\
        \hline
        Kalman filter attitude&8&integer quaternion\\
        \hline
        Kalman filter rates&6&integer vector\\
        \hline
        \multicolumn{1}{|r|}{\bfseries Total :}&30&\\
        \hline
    \end{tabular}
\end{table}

