% vim: set filetype=tex spell :

\chapter{Software}

\label{ch:Software}
\section{Requirements}

The main requirement of the \ac{ADCS} software is to maintain the \ac{ARC} in a nadir pointing attitude with the Y- face pointing in the ram direction. 

\section{Support Software}

\section{Algorithm Software}

\autoref{fig:swblock} shows the overall software block diagram for the \ac{ADCS} system. Field measurements from the magnetometer are calibrated using the current torquer state and a table of field measurements at different torquer states. The calibrated readings are used to calculate rotation rate and latitude which a long with the field readings are used to calculate the torque that should be applied to the satellite. The torque is then quantized based on \autoref{fig:lpmtq}. The torquers to flip are chosen based current knowledge of torquer stated as well as the desired torque.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance = 3cm, auto]
    % Place nodes
    \node [block] (field) {Field Measurements};
    \node [block,right of=field] (cal) {Torquer Calibration};
    \node [point,right of=cal] (split) {};
    \node [block, right of=split,node distance=1.5cm] (alg) {Torque algorithm};
    \node [block, right of=alg] (q) {Torque Quantization};
    \node [block, above of=alg] (rates) {Rotation Rate Calculations};
    \node [block, below of=alg] (win) {Bias Window Determination};
    \node [point, below of=win] (push) {};
    \node [block, right of=q] (choose) {Choose Torquers to fire};
    \node [point, right of=choose] (fb) {};
    \node [block, right of=fb,node distance=1.5cm] (fire) {Fire Torquers};
    \node [block, below of=choose] (mem) {Torquer Status Tracking};
    %\node [block, below of=choose] (mem) {$Z^{-1}$};

    %draw lines
    \path [conn] (field) -- (cal);
    \path [conn] (split) |- (rates);
    \path [conn] (split) |- (win);
    \path [conn] (cal) -- (alg);
    \path [conn] (rates) -- (alg);
    \path [conn] (win) -- (alg);
    \path [conn] (alg) -- (q);
    \path [conn] (q) -- (choose);
    \path [conn] (choose) -- (fire);
    \path [conn] (fb) |- (mem);
    \path [conn] (mem) -- (choose);
    \path [line] (mem) |- (push);
    \path [conn] (push) -| (cal);


    \end{tikzpicture}
    \caption{Overall Software Block Diagram}
    \label{fig:swblock}
\end{figure}

\subsection{Mode 1}

\autoref{fig:mode1} shows the Mode 1 torque algorithm block diagram. In Mode 1 the required torque is simply calculated using rotation rates and field measurements with \autoref{eqn:crossl}. This is also sometimes referred to as the detumble phase because the tumbling motion of the satellite is slowed down to a rate that makes it easier to get into the proper alignment.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance = 3cm, auto]
    % Place nodes
    \node [input] (field) {Magnetic Field};
    \node [block, right of=field] (alg) { $k {{\vect{\omega}_{err} \cross \vect{B}} \over{\vect{B} \cdot \vect{B}}}$ };
    \node [input, right of=alg] (rates) {Rotation Rates};
    \node [point, below of=alg] (out) {};

    %draw lines
    \path [conn] (field) -- (alg);
    \path [conn] (rates) -- (alg);
    \path [conn] (alg) -- (out);


    \end{tikzpicture}
    \caption{Mode 1 Torque Algorithm Block Diagram}
    \label{fig:mode1}
\end{figure}

\subsection{Mode 2}

\autoref{fig:mode2} shows the Mode 2 torque algorithm block diagram. Torque is calculated the same way as in Mode 1 but this time a bias is added depending on which region of the orbit the satellite is in. The bias tends to cause the satellite to rotate. This causes the algorithm to cancel out the bias. This is prevented by preventing the resulting dipole moment from being in the opposite direction as the bias. Outside of the bias regions the torquers are set to produce no torque.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance = 3cm, auto]
    % Place nodes
    \node [input] (field) {Magnetic Field};
    \node [block, right of=field] (alg) { $k {{\vect{\omega}_{err} \cross \vect{B}} \over{\vect{B} \cdot \vect{B}}}$ };
    \node [input, right of=alg] (rates) {Rotation Rates};
    \node [oppr,below of=alg,node distance=2cm] (sum) {+};
    \node [block,left of=sum,node distance=3cm] (bias) {Mode 2 bias table};
    \node [input,left of=bias] (win) {Bias Window};
    \node [block,below of=sum,node distance=2cm] (fix) {Bias Fix};
    \node [block,below of=fix,node distance=2.5cm] (coast) {Coast?};
    \node [point, below of=coast] (out) {};

    %draw lines
    \path [conn] (field) -- (alg);
    \path [conn] (rates) -- (alg);
    \path [conn] (alg) -- (sum);
    \path [conn] (win) -- (bias);
    \path [conn] (bias) -- (sum);
    \path [conn] (sum) -- (fix);
    \path [conn] (fix) -- (coast);
    \path [conn] (win) |- (coast);
    \path [conn] (coast) -- (out);

    \end{tikzpicture}
    \caption{Mode 2 Torque Algorithm Block Diagram}
    \label{fig:mode2}
\end{figure}

\subsection{Mode 3}

\autoref{fig:mode3} shows the Mode 3 torque algorithm block diagram. This is similar to Mode 2 except only the north pole bias window is used and outside the bias window torque is generated to slow rotation rates.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance = 3cm, auto]
    % Place nodes
    \node [input] (field) {Magnetic Field};
    \node [block, right of=field] (alg) { $k {{\vect{\omega}_{err} \cross \vect{B}} \over{\vect{B} \cdot \vect{B}}}$ };
    \node [input, right of=alg] (rates) {Rotation Rates};
    \node [oppr,below of=alg,node distance=2cm] (sum) {+};
    \node [block,left of=sum,node distance=3cm] (bias) {Mode 3 bias table};
    \node [input,left of=bias] (win) {Bias Window};
    \node [block,below of=sum,node distance=2cm] (fix) {Bias Fix};
    \node [point, below of=fix] (out) {};

    %draw lines
    \path [conn] (field) -- (alg);
    \path [conn] (rates) -- (alg);
    \path [conn] (alg) -- (sum);
    \path [conn] (win) -- (bias);
    \path [conn] (bias) -- (sum);
    \path [conn] (sum) -- (fix);
    \path [conn] (fix) -- (out);


    \end{tikzpicture}
    \caption{Mode 3 Torque Algorithm Block Diagram}
    \label{fig:mode3}
\end{figure}

\subsection{Mode Switching}

Mode switching on \ac{ARC} will be time based. The original simulation used the rotation rates to switch from Mode 1 mode to Mode 2 but it was found that when the satellite did not have full knowledge of rotation rates, as will be the case if they are determined from magnetic field, then the mode was switched too soon. The switch from Mode 2 to Mode 3 is timed to be about 10 orbits after the switch into Mode 2. Once in Mode 3 no more automated mode switching is done. Modes can also be switched at all times via ground station command.

\subsection{Bias Window Determination}

\autoref{fig:biaswin} shows how the bias window determination will work. To determine where \ac{ARC} is within the orbit, peaks are found in the magnitude of the magnetic field. The field magnitude is used because it is independent of attitude. The magnitude of the field is greatest at the south pole but the magnetic north pole is located closer to the geographic north pole so it's peaks are more consistent. South pole peaks are filtered out first by eliminating peaks that are ether too high or too low to be a north pole peak. Peaks are further filtered by tracking the timing of past peaks and rejecting peaks that happen too soon. If a second peak is detected very soon after a north pole peak then it is assumed to be a double peak and the average peak time is taken. After the north poles are found the orbital period can be determined and orbital progress can be tracked. The current bias window is determined using the current orbital progress and a lookup table. In case the automatic orbit tracking does not work properly it is possible to upload timing parameters for the orbit tracking to use instead.

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance = 3cm, auto]
    % Place nodes
    \node [input] (field) {Field Measurements};
    \node [block,below of=field,node distance=2.1cm] (mag) {Vector Magnitude};
    \node [block,right of=mag] (peak) {Peak Detect};
    \node [block,right of=peak] (level) {Level Check};
    \node [block,right of=level] (pole) {North Pole Detect};
    \node [block,right of=pole] (gen) {Orbit tracking};
    \node [block,below of=gen,node distance=2.5cm] (time) {Timing Source};
    \node [block,above of=gen] (upload) {Timing Parameter Upload};
    \node [block,right of=gen] (lookup) {Bias Window Lookup};
    \node [point,right of=lookup,node distance=2cm] (out) {};

    %draw lines
    \path [conn] (field) -- (mag);
    \path [conn] (mag) -- (peak);
    \path [conn] (peak) -- (level);
    \path [conn] (level) -- (pole);
    \path [conn] (pole) -- (gen);
    \path [conn] (gen) -- (lookup);
    \path [conn] (lookup) -- (out);
    \path [conn] (time) -- (gen);
    \path [conn,dashed] (upload) -- (gen);

    \end{tikzpicture}
    \caption{Bias Window Determination Block Diagram}
    \label{fig:biaswin}
\end{figure}

\begin{comment}
\subsection{Rotation Rate Calculations}

The rotation rate is calculated using the magnetic field measurements. \autoref{eqn:magrate} shows how to calculate the rotation rate using magnetic field measurements. In \autoref{eqn:magrate} $\dot{\vec{B}}$ is calculated using there magnetic field measurements and the central difference formula as suggested in \cite{Mentch11}.

\begin{equation}
    %TODO: add dot over B
    \vec{\omega}={\dot{\vec{B}} \cross \vec{B} \over{\vec{B} \cdot \vec{B}}}
    \label{eqn:magrate}
\end{equation}
\end{comment}

\subsection{Kalman Filter}

\begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance = 3cm, auto]
    % Place nodes
        \node [block] (pstate) {Project State};
        \node [block,below of=pstate] (pcov) {Project Error Covariance Ahead};
        \node [block,right of=pcov] (gain) {Compute Kalman Gain};
        \node [block,right of=gain] (ustate) {Update state Estimate};
        \node [block,above of=ustate] (ucov) {Update Error Covariance};


    %draw lines

    \end{tikzpicture}
    \caption{Extended Kalman Filter}
    \label{fig:eKalman}
\end{figure}


\subsection{Torquer Calibration}

The \ac{ADCS} algorithm needs to measure the local magnetic field to determine latitude and for \autoref{eqn:crossl}. The torquers produce a magnetic field which will interfere with the field measurements of the magnetometers. Because the field of each torquer can take on one of two discrete states it is possible to generate a calibration table that will remove the effects of the torquers if the torquer status is known.

